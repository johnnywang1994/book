import{_ as e,o as s,c as a,f as n}from"./app-da643460.js";const o={},c=n(`<h1 id="dockerfile-技術篇" tabindex="-1"><a class="header-anchor" href="#dockerfile-技術篇" aria-hidden="true">#</a> Dockerfile 技術篇</h1><p>本篇主要紀錄dockerfile的使用方法與筆記</p><h2 id="basic-概念" tabindex="-1"><a class="header-anchor" href="#basic-概念" aria-hidden="true">#</a> Basic 概念</h2><p>Docker 能夠經由 <code>Dockerfile</code> 自動化構建images，<code>Dockerfile</code>為一個文本檔，</p><p>其中包含所有使用者可用於構建 images 的指令，透過<code>docker build</code>指令，即可自動化構建</p><p>images ，執行原本需要數行的指令。</p><p>預設上，Dockerfile 即命名為<code>Dockerfile</code> 並置於您專案的根目錄中。</p><h2 id="使用方法" tabindex="-1"><a class="header-anchor" href="#使用方法" aria-hidden="true">#</a> 使用方法</h2><p>執行 <code>docker build</code> 指令時，會將 <code>Dockerfile</code> 的內容傳給 Docker Daemon 進行解析，</p><p>若於解析時發生Syntax等問題，會即時跳出 ERROR。</p><p>預設行為下，若具有cache，Docker會re-use中間images，以加快解析速度，在console output中可以</p><p>看到<code>Using cache</code>的提示。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> build <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><em><strong>注意!! 勿將path設定為 / ，設為 / 會視為您要build 整個hard drive的 根目錄</strong></em></p><p><code>-f</code> 指定構建的Dockerfile 來源</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> build <span class="token parameter variable">-f</span> /path/to/a/Dockerfile
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="編輯格式" tabindex="-1"><a class="header-anchor" href="#編輯格式" aria-hidden="true">#</a> 編輯格式</h2><p><code>INSTRUCTION arguments</code></p><p><em><strong>INSTRUCTION並非 case-sensitive</strong></em></p><p>習慣上使用大寫，方便閱讀與arguments做區別。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>RUN <span class="token builtin class-name">echo</span> <span class="token string">&#39;Test some cool things&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><em><strong>註解符號 #</strong></em></p><p>Docker 視 <code>#</code> 後面的內容為註解</p><p><em><strong>跳脫字元</strong></em></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># escape=\\ (backslash)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>OR</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># escape=\` (backtick)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Docker 使用 <code>\\</code> 或 <code>backtick</code> 作為跳脫符號，但當在windows作業系統下時，使用 \\ 可能造成路徑解析錯誤，</p><p>此時可使用escape的parse directive指定使用 <code>backtick</code> 作為跳脫符號。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># escape=\`</span>

FROM microsoft/nanoserver
COPY testfile.txt c:<span class="token punctuation">\\</span>
RUN <span class="token function">dir</span> c:<span class="token punctuation">\\</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="dockerignore-檔案" tabindex="-1"><a class="header-anchor" href="#dockerignore-檔案" aria-hidden="true">#</a> .dockerignore 檔案</h2><p>在docker CLI 將context內容送給docker daemon解析前，它會先在根目錄查找</p><p>檔名為 <code>.dockerignore</code> 的檔案，若此檔案存在，CLI會自動剔除匹配到內部相關的檔案</p><p>可避免不必要的檔案傳輸或較敏感的資料流出，當使用 COPY 或 ADD 指令時。</p><p>範例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># comment</span>
*/temp*
*/*/temp*
temp?
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>*/temp*</code> 在第一層路徑下，剔除檔名或路徑開頭為 temp 的資料</p><p><code>*/*/temp*</code> 在第二層路徑下，剔除檔名或路徑開頭為 temp 的資料</p><p><code>temp?</code> 剔除根目錄下，檔名開頭為 temp 的資料</p><p>匹配機制使用 Go&#39;s filepath.Match 的規則。</p><p><em><strong>! 特例行為</strong></em></p><p>(待補)</p><h2 id="常見-instruction" tabindex="-1"><a class="header-anchor" href="#常見-instruction" aria-hidden="true">#</a> 常見 INSTRUCTION</h2><p><em><strong>FROM</strong></em></p><p>設置構建的Base Image，一個 valid 的 Dockerfile 中，必須由 FROM 起頭撰寫。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>FROM <span class="token operator">&lt;</span>image<span class="token operator">&gt;</span><span class="token punctuation">[</span>:<span class="token operator">&lt;</span>tag<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>AS <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>ARG</code> 參數指令是唯一可以優於 <code>FROM</code> 指令的。</p><p><code>FROM</code> 指令可以在一個 Dockerfile 中出現數次，用以建立多個images，</p><p>每次呼叫<code>FROM</code>指令都會將上一個指令所構建的狀態都清除。</p><p>每次使用 <code>FROM</code> 時，都可以在其後加上 <code>As name</code>，該 name 可以用於之後的 <code>FROM</code></p><p>或 <code>COPY --from=&lt;name|index&gt;</code> 呼叫使用。</p><p><em><strong>ARG</strong></em></p><p><code>FROM</code> 指令支援所有在其之前定義的ARG 參數。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ARG  <span class="token assign-left variable">CODE_VERSION</span><span class="token operator">=</span>latest
FROM base:<span class="token variable">\${CODE_VERSION}</span>
CMD  /code/run-app

FROM extras:<span class="token variable">\${CODE_VERSION}</span>
CMD  /code/run-extras
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ARG</code> 指令定義的參數，因為是與<code>FROM</code>所構建的狀態分離，故無法再用於<code>FROM</code>指令後，</p><p>若需要再次使用相同參數值時，可簡單再於使用前呼叫 <code>ARG</code> 並省略 value</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ARG <span class="token assign-left variable">VERSION</span><span class="token operator">=</span>latest
FROM busybox:<span class="token variable">$VERSION</span>
ARG VERSION
RUN <span class="token builtin class-name">echo</span> <span class="token variable">$VERSION</span> <span class="token operator">&gt;</span> image_version
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em><strong>RUN</strong></em></p><p><code>RUN</code> 指令有兩種格式：</p><ol><li><p><code>RUN &lt;command&gt;</code> shellform，指令執行在shell，預設使用 <code>/bin/sh -c</code> on Linux 及 <code>bash /S /C</code> on Windows</p></li><li><p><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> exec form</p></li></ol><p>RUN 指令會執行任何命令在目前image的最上層，並送出結果，被送出的image結果會繼續使用於後續的Dockerfile中。</p><p>exec form可避免shell的改寫，會用 base image 來 RUN commands。</p><p>可用 \\ 在shellform中換行輸入</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>RUN /bin/bash <span class="token parameter variable">-c</span> <span class="token string">&#39;source $HOME/.bashrc; \\
echo $HOME&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>same as</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>RUN /bin/bash <span class="token parameter variable">-c</span> <span class="token string">&#39;source $HOME/.bashrc; echo $HOME&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>若希望使用別的shell，可使用 execform 指定需要的shell</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>RUN <span class="token punctuation">[</span><span class="token string">&quot;/bin/bash&quot;</span>, <span class="token string">&quot;-c&quot;</span>, <span class="token string">&quot;echo hello&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因exec form使用JSON格式，故務必使用 <code>&quot;</code> 雙引號</p><p><em><strong>CMD</strong></em></p><p>主要用於提供container 的default執行</p><p>共有三種格式：</p><ol><li><p><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> (exec form, this is the preferred form)</p></li><li><p><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> (as default parameters to ENTRYPOINT)</p></li><li><p><code>CMD command param1 param2</code> (shellform)</p></li></ol><p>一個Dockerfile中只能有一個<code>CMD</code>指令，超過一個時，只會執行最後出現的一個</p><p>當使用<code>docker run</code>其他參數時，內部 CMD 預設行為將被替換，舉例：(取IP)</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>FROM ubuntu:18.04
RUN <span class="token function">apt-get</span> update <span class="token punctuation">\\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">curl</span> <span class="token punctuation">\\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/apt/lists/*
CMD <span class="token punctuation">[</span> <span class="token string">&quot;curl&quot;</span>, <span class="token string">&quot;-s&quot;</span>, <span class="token string">&quot;https://ip.cn&quot;</span> <span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我們使用 <code>docker build -t myip .</code> 構建image，並執行</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run myip
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但若需要加上參數使用時，例如加上 <code>-i</code>，加上後執行</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run myip <span class="token parameter variable">-i</span>
docker: Error executable <span class="token function">file</span> not found
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因為根在image名後面的是command，運行時會替換<code>CMD</code>的默認值，並非添加在其後面。</p><p>若須加上<code>-i</code>這參數，必須重新輸入所有command，很麻煩的，故此時就可用下方<code>ENTRYPOINT</code>解決此問題</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run myip <span class="token function">curl</span> <span class="token parameter variable">-s</span> https://ip.cn <span class="token parameter variable">-i</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><em><strong>ENTRYPOINT</strong></em></p><p>格式和 RUN 指令相同，目的和CMD相同，都是在指定容器啟動程序及參數。</p><p>在運行時也可替代，需使用<code>docker run --entrypoint</code>來指定。</p><p>延續上方<code>CMD</code>的範例，並修改為</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>FROM ubuntu:18.04
RUN <span class="token function">apt-get</span> update <span class="token punctuation">\\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">curl</span> <span class="token punctuation">\\</span>
    <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/apt/lists/*
ENTRYPOINT <span class="token punctuation">[</span> <span class="token string">&quot;curl&quot;</span>, <span class="token string">&quot;-s&quot;</span>, <span class="token string">&quot;https://ip.cn&quot;</span> <span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次嘗試就成功了，這是因為當指定<code>ENTRYPOINT</code>後，<code>CMD</code>就不再是直接運行，</p><p>而是將內容傳給<code>ENTRYPOINT</code>。</p><p><em><strong>LABEL</strong></em></p><p>為image記載相關metadata</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>LABEL <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">&quot;1.0&quot;</span>
LABEL <span class="token assign-left variable">description</span><span class="token operator">=</span><span class="token string">&quot;This text cool&quot;</span>
LABEL <span class="token assign-left variable">maintainer</span><span class="token operator">=</span><span class="token string">&quot;johnnywang@home.org.com&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可用 <code>docker inspect</code> 查看</p><p><em><strong>EXPOSE</strong></em></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>EXPOSE <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>port<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>protocol<span class="token operator">&gt;</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>EXPOSE</code> 指示Docker Container在runtime時，所listen的ports</p><p><code>EXPOSE</code> 指令並沒有實際 publish port，僅用以提供使用者應該publish到哪個port</p><p>預設EXPOSE 使用TCP，也可指定為UDP</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>EXPOSE <span class="token number">80</span>/udp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用 <code>docker network</code> 提供container間的溝通，即可不必設定EXPOSE及publish位置</p><p><em><strong>ADD, COPY</strong></em></p><p>格式和性質基本相同，但ADD在COPY上增加一些功能。比如<code>&lt;src&gt;</code>可以是URL，</p><p>另外ADD 複製的檔案若為壓縮檔，將會自董解壓縮處理。但若僅需複製就好時，必須使用COPY。</p><p>建議盡量使用功能較單純的COPY，因ADD包含較多複雜功能，行為不一定很清晰，通常只在需要解壓縮的場合使用。</p><p>有兩種格式：</p><ol><li><p><code>ADD|COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></p></li><li><p><code>ADD|COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code> (當path包含空格時，需使用此格式)</p></li></ol><p>從<code>&lt;src&gt;</code>複製新檔案並新增到<code>&lt;dest&gt;</code>，當需要查找檔名包含<code>[, ]</code>等，必須使用Golang規則，</p><p>如下範例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ADD hom* /mydir/        <span class="token comment"># adds all files starting with &quot;hom&quot;</span>
ADD hom?.txt /mydir/    <span class="token comment"># ? is replaced with any single character, e.g., &quot;home.txt&quot;</span>

ADD arr<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token number">0</span><span class="token punctuation">]</span>.txt /mydir/    <span class="token comment"># copy a file named &quot;arr[0].txt&quot; to /mydir/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用時須遵守以下幾點：</p><ol><li><p><code>&lt;src&gt;</code>路徑必須在context中，不可使用如 <code>ADD ../something /something</code></p></li><li><p>若<code>&lt;src&gt;</code>是一個URL，且<code>&lt;dest&gt;</code>不以trailing slash結尾，檔案將從url下載後複製進<code>&lt;dest&gt;</code></p></li><li><p>若<code>&lt;src&gt;</code>是一個URL，但<code>&lt;dest&gt;</code>以trailing slash結尾，檔案將從url下載後複製<code>&lt;dest&gt;/&lt;filename&gt;</code>，</p><p>例如，<code>ADD http://example.com/foobar /</code> 會建立 <code>/foobar</code> 檔案</p></li><li><p>若<code>&lt;src&gt;</code>是一個目錄，則該目錄下的所有內容都將被複製，包括檔案系統metadata，目錄本身不會被複製，僅內容</p></li></ol><p><em><strong>VOLUME</strong></em></p><p>VOLUME [&quot;/data&quot;]</p><p>(待補)</p><p><em><strong>WORKDIR</strong></em></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>WORKDIR /path/to/workdir
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>為所有<code>RUN, CMD, ENTRYPOINT, COPY, ADD</code> 等指令，設置working directory</p><p><code>WORKDIR</code> 可以在一個Dockerfile內使用多次，若使用相對位置時，會自動比對上一個<code>WORKDIR</code>的位置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>WORKDIR /a
WORKDIR b
WORKDIR c
RUN <span class="token builtin class-name">pwd</span>

<span class="token comment"># /a/b/c</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em><strong>ONBUILD</strong></em></p><p>(待補)</p>`,122),i=[c];function t(d,p){return s(),a("div",null,i)}const r=e(o,[["render",t],["__file","dockerfile-demo.html.vue"]]);export{r as default};
