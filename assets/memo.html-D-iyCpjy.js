import{_ as a,c as n,d as s,o as t}from"./app-DUXFSTbR.js";const i={};function l(o,e){return t(),n("div",null,e[0]||(e[0]=[s(`<h1 id="graphql-memo" tabindex="-1"><a class="header-anchor" href="#graphql-memo"><span>GraphQL Memo</span></a></h1><p>這邊會記錄一些我在學習 GraphQL 時的一些個人心得跟想法～</p><h2 id="幫助記憶" tabindex="-1"><a class="header-anchor" href="#幫助記憶"><span>幫助記憶</span></a></h2><h3 id="field-與-type-到底差別在哪裡" tabindex="-1"><a class="header-anchor" href="#field-與-type-到底差別在哪裡"><span>field 與 type 到底差別在哪裡</span></a></h3><p>field 是組成 Object Type 的欄位， type 為 field 展現的資料格式</p><h3 id="schema-欄位不是直接跟-db-table-欄位對應-可以根據需要調整" tabindex="-1"><a class="header-anchor" href="#schema-欄位不是直接跟-db-table-欄位對應-可以根據需要調整"><span>Schema 欄位不是直接跟 DB Table 欄位對應，可以根據需要調整</span></a></h3><p>聽起來像廢話，但一開始學習時有可能搞不太懂而以為 Schema 必須照著 DB Table 設計走，<code>query</code> 像是 rest api 裡的 <code>get</code> 方法，我們可以根據需求決定具體給出什麼欄位讓使用者能夠獲得資料，比如常見的 <code>User</code> 雖然 DB 裡會存有 <code>password</code> 欄位，但我們不會希望 Client 端能夠 query 得到它，此時就不必在 <code>User</code> 的 Schema</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">type User <span class="token punctuation">{</span></span>
<span class="line">  <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token constant">ID</span><span class="token operator">!</span></span>
<span class="line">  <span class="token literal-property property">name</span><span class="token operator">:</span> String<span class="token operator">!</span></span>
<span class="line">  <span class="token literal-property property">email</span><span class="token operator">:</span> String<span class="token operator">!</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="authentication-vs-authorizaion-差別" tabindex="-1"><a class="header-anchor" href="#authentication-vs-authorizaion-差別"><span>Authentication vs Authorizaion 差別</span></a></h3><p>Authentication 處理的是登入問題，如果登入失敗那就是 Authentication 「認證」的問題 ; Authoriaction 處理的是權限問題，如果登入者或 guest 要進行一項不屬於他權限允許的操作，那就會引發 Authorizaion 「授權」問題。</p>`,10)]))}const p=a(i,[["render",l],["__file","memo.html.vue"]]),c=JSON.parse('{"path":"/articles/memo/graphql/memo.html","title":"GraphQL Memo","lang":"zh-TW","frontmatter":{},"headers":[{"level":2,"title":"幫助記憶","slug":"幫助記憶","link":"#幫助記憶","children":[{"level":3,"title":"field 與 type 到底差別在哪裡","slug":"field-與-type-到底差別在哪裡","link":"#field-與-type-到底差別在哪裡","children":[]},{"level":3,"title":"Schema 欄位不是直接跟 DB Table 欄位對應，可以根據需要調整","slug":"schema-欄位不是直接跟-db-table-欄位對應-可以根據需要調整","link":"#schema-欄位不是直接跟-db-table-欄位對應-可以根據需要調整","children":[]},{"level":3,"title":"Authentication vs Authorizaion 差別","slug":"authentication-vs-authorizaion-差別","link":"#authentication-vs-authorizaion-差別","children":[]}]}],"git":{"updatedTime":1655636083000,"contributors":[{"name":"JohnnyWang","email":"johnnywang@test.com","commits":1}]},"filePathRelative":"articles/memo/graphql/memo.md"}');export{p as comp,c as data};
