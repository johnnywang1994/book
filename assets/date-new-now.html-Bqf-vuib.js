import{_ as o,c as s,b as a,a as n,d as c,r as d,o as i}from"./app-DPsCAi97.js";const p={};function h(r,e){const t=d("SocialBlock");return i(),s("div",null,[e[0]||(e[0]=a("h1",{id:"date-now-與-new-date",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#date-now-與-new-date"},[a("span",null,"Date.now() 與 new Date()")])],-1)),n(t,{hashtags:"javascript,date"}),e[1]||(e[1]=c('<p>本篇探討一些前端的時間戳記理解，提供給大家參考：</p><p>大家都知道 <code>Date.now</code> 就是一個 Date 物件的方法，可以快速拿到當下的時間，但究竟拿到的是什麼呢？</p><h2 id="快速理解" tabindex="-1"><a class="header-anchor" href="#快速理解"><span>快速理解</span></a></h2><p>Date.now() 與 new Date() 直接調用後的機制相同，都是取得 UTC 的當下時間，也就是全球同步，不論你今天在哪，瀏覽器是什麼，使用這兩個都會拿到相同的時間值。</p><p>如果你只是單純要拿當下時間，不會有什麼大問題，但如果需要進行某個定時來比對時，事情就會變得麻煩了，比如你要做個倒數計時器，或是一個頁面關閉的判斷式。</p><h2 id="主要問題" tabindex="-1"><a class="header-anchor" href="#主要問題"><span>主要問題</span></a></h2><p>Date.now() 與 new Date() 不難理解，但如果是 <code>new Date(&#39;2020-03-18T00:00&#39;)</code> 呢？拿到的時間在世界各地都會相同嗎？</p><h2 id="深入探討" tabindex="-1"><a class="header-anchor" href="#深入探討"><span>深入探討</span></a></h2><p>我們查閱資料可以知道，上面問題的指定時間字符串，因為沒有帶上任何標註時區的字段，所以 js 會自動依照瀏覽器的時區進行設定，假設在台灣的話，就是指定創建一個<code>TW 3/18 00:00</code>，那台灣時間也就是<code>GMP+8</code>，所以可以知道標準時間其實為<code>UTC 3/17 16:00</code>，實際設定時間慢了我們 8 小時。</p><p>首先我們做個比喻，把程式碼比喻成一個商店的牌子，並且把瀏覽器的時區想成商店的位置，而用戶就是某個消費者，當今天日本的商店公告在日本凌晨12點關閉時，對台灣的客人來說，半夜11點時該商店就已經關閉了，</p><p>假設現在我是一個用戶，在 GMT+8 的<code>2020-03-18T00:00</code>這時間瀏覽網頁，並且瀏覽器時區被硬性設定在 UTC 時間，原本的期望是在這時間之後開啟網頁某些內容，但因為瀏覽器時區實際是慢 8 小時，所以瀏覽器內的時間其實還在<code>2020-03-17T16:00</code>，並未到達設定的 <code>2020-03-18T00:00</code>，所以網頁上的內容被未如期出現。</p><h2 id="總結整理" tabindex="-1"><a class="header-anchor" href="#總結整理"><span>總結整理</span></a></h2><p><strong>發生原因：</strong></p><p>雖然預設時區是依照用戶自己設定的瀏覽器時區，所以大部分情況下在前端用 js 拿時間都是沒有問題的，但像是一些App內瀏覽器，可能App供應商為了世界各地的經營考量，會將該瀏覽器時區統一設定，避免用戶自行更改時區導致問題。</p><p>此時在該瀏覽器下取得的時間，就會與實際使用者當下的時間有所差別，也就會發生類似上面的，使用者已經12點了，但App內瀏覽器還沒的問題。</p><p><strong>解決辦法：</strong></p><p>根據不同的用戶地區，將前端程式碼的時間預先加或減實際瀏覽器時區的時間差，例如我希望讓我 UTC 時區的瀏覽器，能夠在 GMP+8 時區的玩家在半夜 00 點看到上線的活動，那我就必須在程式碼中設定前一天的 16:00。</p><h2 id="常見狀況" tabindex="-1"><a class="header-anchor" href="#常見狀況"><span>常見狀況</span></a></h2><p>通常，對於時區換算這件事會由後端完成，前端拿到絕對的 UTC 時間後再進行判斷就不會有問題，但如果必須完全依賴前端完成時間判斷時，就必須知道前端 Date 物件的行為模式，記住下面這句來自 W3School 的說明</p><blockquote><p>when getting a date object without specific timezone, it returns UTC time with the browser timezone.(same time in different zone)</p></blockquote><blockquote><p>when setting a date object without specific timezone, it set the date with the browser timezone.(different UTC time in different zone)</p></blockquote><p>所以當瀏覽器時區跟使用者時區不同，而你又一定要進行 set Date 物件的動作時，那就是要進行換算的時候了。</p>',22)),n(t,{hashtags:"javascript,date"})])}const l=o(p,[["render",h]]),w=JSON.parse('{"path":"/articles/js/date-new-now.html","title":"Date.now() 與 new Date()","lang":"zh-TW","frontmatter":{},"git":{"updatedTime":1648521821000,"contributors":[{"name":"Johnny Wang","username":"","email":"wangj@garena.com","commits":1},{"name":"johnnywang1994","username":"johnnywang1994","email":"johnny29621189@kimo.com","commits":2,"url":"https://github.com/johnnywang1994"}],"changelog":[{"hash":"71ccb7693345c8ddc2f554e00f8a0ce73af2b783","time":1648521821000,"email":"johnny29621189@kimo.com","author":"johnnywang1994","message":"UPD: upgrade to v2"},{"hash":"da1521dcf805739a83e5efa4e52581013a51dcad","time":1638541816000,"email":"johnny29621189@kimo.com","author":"johnnywang1994","message":"UPD: update sociallinks"},{"hash":"51e618d93d4f837fbce25a1e1f0a9783cbc46b6a","time":1624012650000,"email":"wangj@garena.com","author":"Johnny Wang","message":"INIT"}]},"filePathRelative":"articles/js/date-new-now.md"}');export{l as comp,w as data};
